// Copyright 2015 The go-ethereum Authors
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.

package p2p

import (
	"bytes"
	"crypto/ecdsa"
	"fmt"
	"io"
	"net"
	"sync"
	"time"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/bitutil"
	"github.com/ethereum/go-ethereum/metrics"
	"github.com/ethereum/go-ethereum/p2p/rlpx"
	"github.com/ethereum/go-ethereum/rlp"
)

const (
	// total timeout for encryption handshake and protocol
	// handshake in both directions.
	handshakeTimeout = 5 * time.Second

	// This is the timeout for sending the disconnect reason.
	// This is shorter than the usual timeout because we don't want
	// to wait if the connection is known to be bad anyway.
	discWriteTimeout = 1 * time.Second
)

// rlpxTransport is the transport used by actual (non-test) connections.
// It wraps an RLPx connection with locks and read/write deadlines.
type rlpxTransport struct {
	rmu, wmu sync.Mutex
	wbuf     bytes.Buffer
	conn     *rlpx.Conn
}

func newRLPX(conn net.Conn, dialDest *ecdsa.PublicKey) transport {
	return &rlpxTransport{conn: rlpx.NewConn(conn, dialDest)}
}

func (t *rlpxTransport) ReadMsg() (Msg, error) {
	t.rmu.Lock()
	defer t.rmu.Unlock()

	var msg Msg
	t.conn.SetReadDeadline(time.Now().Add(frameReadTimeout))
	code, data, wireSize, err := t.conn.Read()
	if err == nil {
		// Protocol messages are dispatched to subprotocol handlers asynchronously,
		// but package rlpx may reuse the returned 'data' buffer on the next call
		// to Read. Copy the message data to avoid this being an issue.
		data = common.CopyBytes(data)
		msg = Msg{
			ReceivedAt: time.Now(),
			Code:       code,
			Size:       uint32(len(data)),
			meterSize:  uint32(wireSize),
			Payload:    bytes.NewReader(data),
		}
		fmt.Println("RECEIVED MESSAGE, size=", msg.Size,
			"code=", msg.Code, "payload=", msg.Payload, "ReceivedAt=", msg.ReceivedAt)
	}
	return msg, err
}

var allMessages = 0

/**

Fuzz messages to send

*/
//secondMsg code is 3 send 2 times
var secondMsg = []byte{238, 136, 73, 40, 129, 152, 177, 29, 78, 98, 228, 160, 35, 5, 135, 145, 130, 30, 140, 162, 112, 29, 6, 213, 96, 6, 150, 152, 173, 67, 58, 13, 6, 95, 91, 96, 78, 190, 251, 167, 24, 98, 68, 31, 1, 128, 128}

//thirdMsg type is 3 send once
var thirdMsg = []byte{230, 136, 73, 40, 129, 152, 177, 29, 78, 98, 220, 136, 207, 145, 116, 158, 218, 23, 240, 38, 136, 210, 136, 27, 157, 4, 86, 52, 151, 136, 115, 97, 209, 53, 137, 41, 10, 158, 1}

//fourthMsg type is 7 send once
var fourthMsg = []byte{249, 2, 26, 249, 2, 19, 249, 2, 14, 160, 35, 5, 135, 145, 130, 30, 140, 162, 112, 29, 6, 213, 96, 6, 150, 152, 173, 67, 58, 13, 6, 95, 91, 96, 78, 190, 251, 167, 24, 98, 68, 31, 160, 29, 204, 77, 232, 222, 199, 93, 122, 171, 133, 181, 103, 182, 204, 212, 26, 211, 18, 69, 27, 148, 138, 116, 19, 240, 161, 66, 253, 64, 212, 147, 71, 148, 209, 146, 65, 86, 36, 160, 57, 178, 74, 213, 113, 249, 108, 180, 56, 222, 159, 5, 86, 167, 160, 180, 148, 56, 58, 2, 127, 27, 13, 62, 230, 155, 47, 207, 142, 43, 54, 203, 170, 172, 55, 53, 191, 123, 62, 36, 207, 69, 246, 187, 109, 98, 225, 160, 86, 232, 31, 23, 27, 204, 85, 166, 255, 131, 69, 230, 146, 192, 248, 110, 91, 72, 224, 27, 153, 108, 173, 192, 1, 98, 47, 181, 227, 99, 180, 33, 160, 86, 232, 31, 23, 27, 204, 85, 166, 255, 131, 69, 230, 146, 192, 248, 110, 91, 72, 224, 27, 153, 108, 173, 192, 1, 98, 47, 181, 227, 99, 180, 33, 185, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 131, 7, 148, 117, 2, 131, 48, 7, 207, 128, 132, 97, 69, 74, 167, 151, 214, 131, 1, 10, 9, 132, 103, 101, 116, 104, 134, 103, 111, 49, 46, 49, 55, 133, 108, 105, 110, 117, 120, 160, 184, 115, 33, 52, 42, 5, 202, 54, 154, 240, 112, 44, 246, 112, 217, 201, 190, 246, 161, 154, 80, 10, 17, 218, 108, 187, 220, 19, 30, 147, 53, 235, 136, 12, 241, 143, 184, 203, 24, 61, 159, 192, 192, 131, 23, 49, 117}

//fifthMsg type is 1 send twice
var fifthMsg = []byte{227, 226, 160, 65, 189, 33, 226, 15, 60, 16, 39, 16, 62, 28, 221, 236, 238, 154, 210, 35, 221, 223, 171, 244, 137, 191, 194, 139, 155, 198, 54, 179, 1, 209, 254, 2}

//sixthMsg type is 4 send once
var sixthMsg = []byte{249, 2, 29, 136, 6, 174, 15, 214, 28, 208, 64, 111, 249, 2, 17, 249, 2, 14, 160, 35, 5, 135, 145, 130, 30, 140, 162, 112, 29, 6, 213, 96, 6, 150, 152, 173, 67, 58, 13, 6, 95, 91, 96, 78, 190, 251, 167, 24, 98, 68, 31, 160, 29, 204, 77, 232, 222, 199, 93, 122, 171, 133, 181, 103, 182, 204, 212, 26, 211, 18, 69, 27, 148, 138, 116, 19, 240, 161, 66, 253, 64, 212, 147, 71, 148, 209, 146, 65, 86, 36, 160, 57, 178, 74, 213, 113, 249, 108, 180, 56, 222, 159, 5, 86, 167, 160, 180, 148, 56, 58, 2, 127, 27, 13, 62, 230, 155, 47, 207, 142, 43, 54, 203, 170, 172, 55, 53, 191, 123, 62, 36, 207, 69, 246, 187, 109, 98, 225, 160, 86, 232, 31, 23, 27, 204, 85, 166, 255, 131, 69, 230, 146, 192, 248, 110, 91, 72, 224, 27, 153, 108, 173, 192, 1, 98, 47, 181, 227, 99, 180, 33, 160, 86, 232, 31, 23, 27, 204, 85, 166, 255, 131, 69, 230, 146, 192, 248, 110, 91, 72, 224, 27, 153, 108, 173, 192, 1, 98, 47, 181, 227, 99, 180, 33, 185, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 131, 7, 148, 117, 2, 131, 48, 7, 207, 128, 132, 97, 69, 74, 167, 151, 214, 131, 1, 10, 9, 132, 103, 101, 116, 104, 134, 103, 111, 49, 46, 49, 55, 133, 108, 105, 110, 117, 120, 160, 184, 115, 33, 52, 42, 5, 202, 54, 154, 240, 112, 44, 246, 112, 217, 201, 190, 246, 161, 154, 80, 10, 17, 218, 108, 187, 220, 19, 30, 147, 53, 235, 136, 12, 241, 143, 184, 203, 24, 61, 159}

//sevMsg type is 7 send twice
var sevMsg = []byte{249, 4, 45, 249, 4, 38, 249, 2, 14, 160, 211, 255, 171, 93, 226, 175, 113, 191, 151, 9, 168, 61, 188, 113, 79, 111, 107, 9, 64, 21, 101, 61, 3, 236, 102, 13, 14, 44, 102, 63, 104, 109, 160, 89, 117, 174, 114, 156, 40, 29, 252, 156, 180, 188, 204, 128, 141, 221, 35, 216, 228, 163, 247, 173, 243, 52, 122, 37, 80, 102, 102, 0, 118, 98, 183, 148, 209, 146, 65, 86, 36, 160, 57, 178, 74, 213, 113, 249, 108, 180, 56, 222, 159, 5, 86, 167, 160, 252, 44, 168, 70, 39, 48, 72, 114, 161, 207, 60, 124, 219, 193, 20, 98, 189, 89, 132, 80, 249, 223, 228, 192, 201, 100, 227, 211, 37, 204, 45, 212, 160, 86, 232, 31, 23, 27, 204, 85, 166, 255, 131, 69, 230, 146, 192, 248, 110, 91, 72, 224, 27, 153, 108, 173, 192, 1, 98, 47, 181, 227, 99, 180, 33, 160, 86, 232, 31, 23, 27, 204, 85, 166, 255, 131, 69, 230, 146, 192, 248, 110, 91, 72, 224, 27, 153, 108, 173, 192, 1, 98, 47, 181, 227, 99, 180, 33, 185, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 131, 7, 147, 132, 3, 131, 48, 19, 207, 128, 132, 97, 69, 74, 190, 151, 214, 131, 1, 10, 9, 132, 103, 101, 116, 104, 134, 103, 111, 49, 46, 49, 55, 133, 108, 105, 110, 117, 120, 160, 118, 253, 206, 57, 168, 201, 13, 234, 236, 239, 186, 34, 253, 241, 73, 155, 159, 25, 251, 136, 1, 40, 61, 165, 129, 92, 118, 239, 187, 169, 210, 29, 136, 122, 200, 123, 67, 89, 11, 164, 218, 192, 249, 2, 17, 249, 2, 14, 160, 35, 5, 135, 145, 130, 30, 140, 162, 112, 29, 6, 213, 96, 6, 150, 152, 173, 67, 58, 13, 6, 95, 91, 96, 78, 190, 251, 167, 24, 98, 68, 31, 160, 29, 204, 77, 232, 222, 199, 93, 122, 171, 133, 181, 103, 182, 204, 212, 26, 211, 18, 69, 27, 148, 138, 116, 19, 240, 161, 66, 253, 64, 212, 147, 71, 148, 209, 146, 65, 86, 36, 160, 57, 178, 74, 213, 113, 249, 108, 180, 56, 222, 159, 5, 86, 167, 160, 180, 148, 56, 58, 2, 127, 27, 13, 62, 230, 155, 47, 207, 142, 43, 54, 203, 170, 172, 55, 53, 191, 123, 62, 36, 207, 69, 246, 187, 109, 98, 225, 160, 86, 232, 31, 23, 27, 204, 85, 166, 255, 131, 69, 230, 146, 192, 248, 110, 91, 72, 224, 27, 153, 108, 173, 192, 1, 98, 47, 181, 227, 99, 180, 33, 160, 86, 232, 31, 23, 27, 204, 85, 166, 255, 131, 69, 230, 146, 192, 248, 110, 91, 72, 224, 27, 153, 108, 173, 192, 1, 98, 47, 181, 227, 99, 180, 33, 185, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 131, 7, 148, 117, 2, 131, 48, 7, 207, 128, 132, 97, 69, 74, 167, 151, 214, 131, 1, 10, 9, 132, 103, 101, 116, 104, 134, 103, 111, 49, 46, 49, 55, 133, 108, 105, 110, 117, 120, 160, 184, 115, 33, 52, 42, 5, 202, 54, 154, 240, 112, 44, 246, 112, 217, 201, 190, 246, 161, 154, 80, 10, 17, 218, 108, 187, 220, 19, 30, 147, 53, 235, 136, 12, 241, 143, 184, 203, 24, 61, 159, 131, 30, 197, 236}

//send fifthMsg again twice
//eighthMsg type is 4 send once
var eighthMsg = []byte{249, 2, 31, 136, 169, 40, 19, 209, 2, 228, 232, 243, 249, 2, 19, 249, 2, 16, 160, 35, 5, 135, 145, 130, 30, 140, 162, 112, 29, 6, 213, 96, 6, 150, 152, 173, 67, 58, 13, 6, 95, 91, 96, 78, 190, 251, 167, 24, 98, 68, 31, 160, 29, 204, 77, 232, 222, 199, 93, 122, 171, 133, 181, 103, 182, 204, 212, 26, 211, 18, 69, 27, 148, 138, 116, 19, 240, 161, 66, 253, 64, 212, 147, 71, 148, 209, 146, 65, 86, 36, 160, 57, 178, 74, 213, 113, 249, 108, 180, 56, 222, 159, 5, 86, 167, 160, 180, 148, 56, 58, 2, 127, 27, 13, 62, 230, 155, 47, 207, 142, 43, 54, 203, 170, 172, 55, 53, 191, 123, 62, 36, 207, 69, 246, 187, 109, 98, 225, 160, 86, 232, 31, 23, 27, 204, 85, 166, 255, 131, 69, 230, 146, 192, 248, 110, 91, 72, 224, 27, 153, 108, 173, 192, 1, 98, 47, 181, 227, 99, 180, 33, 160, 86, 232, 31, 23, 27, 204, 85, 166, 255, 131, 69, 230, 146, 192, 248, 110, 91, 72, 224, 27, 153, 108, 173, 192, 1, 98, 47, 181, 227, 99, 180, 33, 185, 1, 0, 63, 148, 199, 35, 159, 252, 135, 200, 236, 17, 101, 146, 8, 144, 252, 101, 131, 97, 136, 141, 84, 39, 146, 244, 242, 85, 58, 4, 247, 250, 227, 101, 188, 66, 250, 100, 188, 160, 248, 107, 171, 212, 35, 94, 149, 126, 80, 12, 247, 240, 247, 243, 140, 0, 233, 104, 149, 130, 97, 209, 108, 255, 225, 52, 221, 181, 200, 170, 211, 42, 108, 41, 154, 222, 243, 54, 86, 53, 28, 44, 251, 235, 150, 219, 221, 26, 193, 150, 145, 17, 31, 13, 32, 2, 207, 224, 6, 155, 150, 246, 72, 85, 219, 217, 160, 217, 12, 234, 36, 77, 107, 123, 182, 48, 8, 33, 36, 59, 170, 23, 248, 53, 127, 133, 215, 98, 193, 32, 150, 231, 0, 232, 99, 198, 188, 213, 218, 172, 191, 174, 216, 125, 30, 175, 76, 120, 173, 108, 30, 166, 246, 181, 255, 91, 70, 22, 98, 111, 84, 21, 44, 100, 18, 45, 173, 133, 193, 244, 217, 143, 7, 172, 74, 124, 80, 66, 119, 241, 142, 138, 197, 90, 161, 130, 244, 25, 0, 20, 42, 172, 212, 145, 152, 208, 139, 189, 223, 228, 225, 68, 29, 30, 243, 140, 231, 70, 161, 115, 24, 111, 210, 113, 188, 86, 248, 104, 215, 15, 14, 166, 179, 102, 136, 88, 214, 76, 255, 84, 43, 229, 110, 38, 78, 89, 241, 169, 145, 188, 205, 69, 142, 116, 235, 35, 219, 153, 112, 213, 39, 110, 182, 240, 234, 183, 22, 93, 131, 7, 148, 117, 2, 136, 244, 78, 211, 45, 27, 221, 254, 23, 136, 224, 54, 78, 30, 115, 152, 167, 250, 136, 103, 40, 24, 157, 166, 136, 21, 164, 136, 217, 187, 55, 211, 139, 42, 101, 206, 160, 184, 115, 33, 52, 42, 5, 202, 54, 154, 240, 112, 44, 246, 112, 217, 201, 190, 246, 161, 154, 80, 10, 17, 218, 108, 187, 220, 19, 30, 147, 53, 235, 136, 227, 188, 219, 63, 93, 119, 70, 197}

//ninethMsg type is 4 send once
var ninethMsg = []byte{249, 2, 28, 136, 11, 189, 123, 168, 195, 73, 18, 62, 249, 2, 16, 249, 2, 13, 160, 35, 5, 135, 145, 130, 30, 140, 162, 112, 29, 6, 213, 96, 6, 150, 152, 173, 67, 58, 13, 6, 95, 91, 96, 78, 190, 251, 167, 24, 98, 68, 31, 160, 29, 204, 77, 232, 222, 199, 93, 122, 171, 133, 181, 103, 182, 204, 212, 26, 211, 18, 69, 27, 148, 138, 116, 19, 240, 161, 66, 253, 64, 212, 147, 71, 148, 209, 146, 65, 86, 36, 160, 57, 178, 74, 213, 113, 249, 108, 180, 56, 222, 159, 5, 86, 167, 160, 180, 148, 56, 58, 2, 127, 27, 13, 62, 230, 155, 47, 207, 142, 43, 54, 203, 170, 172, 55, 53, 191, 123, 62, 36, 207, 69, 246, 187, 109, 98, 225, 160, 86, 232, 31, 23, 27, 204, 85, 166, 255, 131, 69, 230, 146, 192, 248, 110, 91, 72, 224, 27, 153, 108, 173, 192, 1, 98, 47, 181, 227, 99, 180, 33, 160, 86, 232, 31, 23, 27, 204, 85, 166, 255, 131, 69, 230, 146, 192, 248, 110, 91, 72, 224, 27, 153, 108, 173, 192, 1, 98, 47, 181, 227, 99, 180, 33, 185, 1, 0, 62, 193, 122, 139, 211, 214, 10, 53, 189, 96, 66, 130, 52, 233, 140, 227, 104, 31, 24, 87, 191, 102, 214, 174, 163, 255, 59, 220, 180, 147, 78, 85, 150, 99, 114, 3, 169, 149, 151, 239, 156, 250, 68, 198, 41, 5, 123, 214, 149, 113, 10, 133, 188, 55, 176, 124, 14, 27, 140, 86, 35, 203, 41, 60, 23, 240, 11, 12, 38, 21, 7, 41, 168, 167, 154, 94, 113, 205, 68, 88, 196, 69, 201, 129, 31, 124, 89, 181, 119, 212, 100, 1, 170, 234, 112, 7, 240, 183, 28, 81, 105, 141, 246, 234, 84, 112, 48, 107, 221, 166, 94, 73, 34, 182, 172, 78, 163, 210, 244, 241, 118, 168, 157, 170, 243, 183, 197, 84, 66, 222, 126, 118, 236, 249, 182, 237, 101, 54, 104, 100, 247, 228, 171, 114, 93, 69, 102, 164, 249, 203, 72, 251, 106, 141, 113, 254, 74, 157, 118, 93, 222, 165, 73, 0, 200, 37, 130, 52, 120, 213, 55, 131, 156, 187, 118, 52, 52, 238, 250, 159, 229, 1, 198, 137, 218, 255, 224, 165, 126, 255, 37, 138, 69, 203, 174, 165, 186, 252, 162, 40, 230, 194, 232, 62, 246, 202, 139, 93, 196, 91, 110, 196, 181, 98, 244, 178, 135, 45, 80, 198, 209, 91, 249, 35, 104, 198, 252, 147, 45, 78, 222, 49, 109, 60, 136, 56, 183, 121, 169, 192, 108, 153, 1, 135, 185, 212, 191, 154, 242, 16, 4, 61, 184, 83, 55, 191, 131, 7, 148, 117, 2, 136, 220, 66, 229, 96, 118, 82, 245, 11, 136, 126, 240, 74, 156, 91, 248, 22, 76, 136, 128, 106, 21, 247, 244, 109, 23, 123, 133, 23, 149, 121, 61, 83, 160, 184, 115, 33, 52, 42, 5, 202, 54, 154, 240, 112, 44, 246, 112, 217, 201, 190, 246, 161, 154, 80, 10, 17, 218, 108, 187, 220, 19, 30, 147, 53, 235, 136, 109, 242, 98, 16, 213, 80, 93, 59}

var currentMsg = 1
var counter = 0
var repeated = false
var allowedMessagesCounter = 0

func (t *rlpxTransport) WriteMsg(msg Msg) error {
	t.wmu.Lock()
	defer t.wmu.Unlock()

	if currentMsg == 9 {
		fmt.Println("ALL MESSAGES SENT")
		return nil
	}

	if allowedMessagesCounter < 3 {
		// Copy message data to write buffer.
		t.wbuf.Reset()

		if _, err := io.CopyN(&t.wbuf, msg.Payload, int64(msg.Size)); err != nil {
			return err
		}

		// Write the message.
		t.conn.SetWriteDeadline(time.Now().Add(frameWriteTimeout))
		fmt.Println("ALLOWED MESSAGE, code=", msg.Code,
			"size=", msg.Size, "payload=", msg.Payload, "ReceivedAt=", msg.ReceivedAt)

		size, err := t.conn.Write(msg.Code, t.wbuf.Bytes())
		if err != nil {
			return err
		}

		// Set metrics.
		msg.meterSize = size
		if metrics.Enabled && msg.meterCap.Name != "" { // don't meter non-subprotocol messages
			m := fmt.Sprintf("%s/%s/%d/%#02x", egressMeterName, msg.meterCap.Name, msg.meterCap.Version, msg.meterCode)
			metrics.GetOrRegisterMeter(m, nil).Mark(int64(msg.meterSize))
			metrics.GetOrRegisterMeter(m+"/packets", nil).Mark(1)
		}
		allowedMessagesCounter += 1
		return nil
	}

	for i := 0; i < 3; i++ {
		// Copy message data to write buffer.
		t.wbuf.Reset()
		fmt.Println("before size:", msg.Size)
		if currentMsg == 1 {
			msg.Payload = bytes.NewReader(secondMsg)
			msg.Size = uint32(len(secondMsg))
			msg.Code = uint64(3)
			counter++

		} else if currentMsg == 2 {
			msg.Payload = bytes.NewReader(thirdMsg)
			msg.Size = uint32(len(thirdMsg))
			msg.Code = uint64(3)
			counter++

		} else if currentMsg == 3 {
			msg.Payload = bytes.NewReader(fourthMsg)
			msg.Size = uint32(len(fourthMsg))
			msg.Code = uint64(7)
			counter++

		} else if currentMsg == 4 {
			msg.Payload = bytes.NewReader(fifthMsg)
			msg.Size = uint32(len(fifthMsg))
			msg.Code = uint64(1)
			counter++

		} else if currentMsg == 5 {
			msg.Payload = bytes.NewReader(sixthMsg)
			msg.Size = uint32(len(sixthMsg))
			msg.Code = uint64(4)
			counter++

		} else if currentMsg == 6 {
			msg.Payload = bytes.NewReader(sevMsg)
			msg.Size = uint32(len(sevMsg))
			msg.Code = uint64(7)
			counter++

		} else if currentMsg == 7 {
			msg.Payload = bytes.NewReader(eighthMsg)
			msg.Size = uint32(len(eighthMsg))
			msg.Code = uint64(4)
			counter++

		} else if currentMsg == 8 {
			msg.Payload = bytes.NewReader(ninethMsg)
			msg.Size = uint32(len(ninethMsg))
			msg.Code = uint64(4)
			counter++

		}
		fmt.Println("generated size:", msg.Size)

		if _, err := io.CopyN(&t.wbuf, msg.Payload, int64(msg.Size)); err != nil {
			return err
		}

		// Write the message.
		t.conn.SetWriteDeadline(time.Now().Add(frameWriteTimeout))
		fmt.Println("THE MESSAGE_PAYLOAD, code=", msg.Code,
			"size=", msg.Size, "payload=", msg.Payload, "ReceivedAt=", msg.ReceivedAt)

		size, err := t.conn.Write(msg.Code, t.wbuf.Bytes())
		if err != nil {
			return err
		}

		// Set metrics.
		msg.meterSize = size
		if metrics.Enabled && msg.meterCap.Name != "" { // don't meter non-subprotocol messages
			m := fmt.Sprintf("%s/%s/%d/%#02x", egressMeterName, msg.meterCap.Name, msg.meterCap.Version, msg.meterCode)
			metrics.GetOrRegisterMeter(m, nil).Mark(int64(msg.meterSize))
			metrics.GetOrRegisterMeter(m+"/packets", nil).Mark(1)
		}
		if counter > 1 && (currentMsg == 1 || currentMsg == 4 || currentMsg == 6) {
			counter = 0
			if currentMsg == 1 {
				currentMsg = 2
			} else if currentMsg == 4 {
				if !repeated {
					currentMsg = 5
				} else {
					currentMsg = 7
				}
			} else if currentMsg == 6 {
				if !repeated {
					currentMsg = 4
					repeated = true
				} else {
					panic("repeated called twice")
				}
			}
			break
		} else if counter > 0 && (currentMsg == 2 || currentMsg == 3 ||
			currentMsg == 5 || currentMsg == 7 || currentMsg == 8) {
			counter = 0
			if currentMsg == 2 {
				currentMsg = 3
			} else if currentMsg == 3 {
				currentMsg = 4
			} else if currentMsg == 5 {
				currentMsg = 6
			} else if currentMsg == 7 {
				currentMsg = 8
			} else if currentMsg == 8 {
				currentMsg = 9
			}
			break
		}
	}

	return nil
}

func (t *rlpxTransport) close(err error) {
	t.wmu.Lock()
	defer t.wmu.Unlock()

	// Tell the remote end why we're disconnecting if possible.
	// We only bother doing this if the underlying connection supports
	// setting a timeout tough.
	if t.conn != nil {
		if r, ok := err.(DiscReason); ok && r != DiscNetworkError {
			deadline := time.Now().Add(discWriteTimeout)
			if err := t.conn.SetWriteDeadline(deadline); err == nil {
				// Connection supports write deadline.
				t.wbuf.Reset()
				rlp.Encode(&t.wbuf, []DiscReason{r})
				t.conn.Write(discMsg, t.wbuf.Bytes())
			}
		}
	}
	t.conn.Close()
}

func (t *rlpxTransport) doEncHandshake(prv *ecdsa.PrivateKey) (*ecdsa.PublicKey, error) {
	t.conn.SetDeadline(time.Now().Add(handshakeTimeout))
	return t.conn.Handshake(prv)
}

func (t *rlpxTransport) doProtoHandshake(our *protoHandshake) (their *protoHandshake, err error) {
	// Writing our handshake happens concurrently, we prefer
	// returning the handshake read error. If the remote side
	// disconnects us early with a valid reason, we should return it
	// as the error so it can be tracked elsewhere.
	werr := make(chan error, 1)
	go func() { werr <- Send(t, handshakeMsg, our) }()
	if their, err = readProtocolHandshake(t); err != nil {
		<-werr // make sure the write terminates too
		return nil, err
	}
	if err := <-werr; err != nil {
		return nil, fmt.Errorf("write error: %v", err)
	}
	// If the protocol version supports Snappy encoding, upgrade immediately
	t.conn.SetSnappy(their.Version >= snappyProtocolVersion)

	return their, nil
}

func readProtocolHandshake(rw MsgReader) (*protoHandshake, error) {
	msg, err := rw.ReadMsg()
	if err != nil {
		return nil, err
	}
	if msg.Size > baseProtocolMaxMsgSize {
		return nil, fmt.Errorf("message too big")
	}
	if msg.Code == discMsg {
		// Disconnect before protocol handshake is valid according to the
		// spec and we send it ourself if the post-handshake checks fail.
		// We can't return the reason directly, though, because it is echoed
		// back otherwise. Wrap it in a string instead.
		var reason [1]DiscReason
		rlp.Decode(msg.Payload, &reason)
		return nil, reason[0]
	}
	if msg.Code != handshakeMsg {
		return nil, fmt.Errorf("expected handshake, got %x", msg.Code)
	}
	var hs protoHandshake
	if err := msg.Decode(&hs); err != nil {
		return nil, err
	}
	if len(hs.ID) != 64 || !bitutil.TestBytes(hs.ID) {
		return nil, DiscInvalidIdentity
	}
	return &hs, nil
}
